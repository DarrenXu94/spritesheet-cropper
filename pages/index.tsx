import type { NextPage } from "next";
import dynamic from "next/dynamic";
import Head from "next/head";
import p5Types from "p5"; //Import this for typechecking and intellisense
import { useEffect, useState } from "react";
import * as url from "../public/adventurer_sprite_sheet_v1.1.png";
import { saveAs } from "file-saver";
import JSZip from "jszip";

const Sketch = dynamic(() => import("react-p5"), {
  ssr: false,
});
let cols = 13;
let rows = 8;
let source;
let w, h;
let tiles: p5Types.Image[] = [];
let tilesPixelArray: Uint8Array[] = [];
let x = 0;

// let datab64: any = null;

const Home: NextPage = () => {
  const [pixelArray, setPixelArray] = useState<any>(null);
  const [downloadFile, setDownloadFile] = useState<any>(null);
  const convertArrayIntoDataUri = (pixelArray) => {
    var canvas = document.createElement("canvas"),
      ctx: any = canvas.getContext("2d");

    canvas.width = 32;
    canvas.height = 32;

    // create imageData object
    var idata = ctx.createImageData(32, 32);

    // set our buffer as source
    idata.data.set(pixelArray);

    // update canvas with new data
    ctx.putImageData(idata, 0, 0);

    var dataUri = canvas.toDataURL(); // produces a PNG file
    return dataUri;
  };
  function dataURLtoFile(dataurl, filename) {
    var arr = dataurl.split(","),
      mime = arr[0].match(/:(.*?);/)[1],
      bstr = atob(arr[1]),
      n = bstr.length,
      u8arr = new Uint8Array(n);
    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }
    return new File([u8arr], filename, { type: mime });
  }
  useEffect(() => {
    if (pixelArray) {
      const zip = new JSZip();

      for (let [idx, croppedImage] of pixelArray.entries()) {
        const convertedImage = convertArrayIntoDataUri(croppedImage);
        console.log({ idx, convertedImage });
        zip.file(`${idx}.png`, dataURLtoFile(convertedImage, `${idx}.png`));
      }
      zip.generateAsync({ type: "blob" }).then(function (content) {
        // saveAs(content, "download.zip");
        setDownloadFile(content);
      });
    }
  }, [pixelArray]);

  const setup = (p5: p5Types, canvasParentRef) => {
    p5.createCanvas(source.width, source.height).parent(canvasParentRef);
    p5.image(source, 0, 0);
    w = source.width / cols;
    h = source.height / rows;
    for (let i = 0; i < cols; i++) {
      for (let j = 0; j < rows; j++) {
        let x = i * w;
        let y = j * h;
        let img = p5.createImage(w, h);
        img.copy(source, x, y, w, h, 0, 0, w, h);

        tiles.push(img);

        img.loadPixels();
        tilesPixelArray.push(new Uint8Array(img.pixels));
      }
    }
    setPixelArray(tilesPixelArray);
  };

  const draw = (p5: p5Types) => {
    p5.image(source, 0, 0);

    // Uncomment for fun animation
    // p5.background(0);
    // if (x < tiles.length - 1) {
    //   x++;
    // } else {
    //   x = 0;
    // }
    // p5.image(tiles[x], 0, 0);
  };
  const download = () => {
    saveAs(downloadFile, "download.zip");
  };
  return (
    <div>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <Sketch
        setup={setup}
        draw={draw}
        preload={(p) => {
          source = p.loadImage(url.default.src);
        }}
      />
      {downloadFile && (
        <button
          onClick={() => {
            download();
          }}
        >
          Download
        </button>
      )}
    </div>
  );
};

export default Home;
